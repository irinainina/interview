# Основы React

**Что такое React?**

* JavaScript-библиотека для создания UI.
* Использует компонентный подход.

**Что такое компонент?**

* Повторно используемый блок UI.
* Может быть функциональным или классовым.

```jsx
function MyComponent() {
  return <div>Hello</div>;
}
```

**JSX — что это?**

* Расширение синтаксиса JS, позволяет писать HTML-подобный код в JS.
* Требует транспиляции (Babel).

**Что такое виртуальный DOM и зачем он нужен?**

* Представление реального DOM в памяти.
* React сравнивает новый виртуальный DOM со старым и минимально обновляет настоящий DOM (diffing + reconciliation).

**Что такое атрибут key и зачем он нужен?**

* Уникальный идентификатор для элементов в списках.
* Помогает React эффективно обновлять элементы при ререндеринге.

---

## Компоненты

**Разница между функциональными и классовыми компонентами?**

* Функциональные проще, используют хуки.
* Классовые — старый подход с `this`, `state`, `lifecycle methods`.

**Что такое props?**

* Входные данные для компонента (read-only).

**Что такое state?**

* Локальное состояние компонента. Обновление state → ререндер.

**Как обновлять state?**

* Через `setState` (в классовых) или `useState` (в функциональных):

```jsx
const [count, setCount] = useState(0);
```

**Что такое поднятие состояния (lifting state up)?**

* Перемещение state в родительский компонент, если он нужен нескольким дочерним.

---

## Жизненный цикл компонента (для классов)

**Фазы жизненного цикла компонента:**

1. Mounting — `constructor`, `render`, `componentDidMount`
2. Updating — `shouldComponentUpdate`, `render`, `componentDidUpdate`
3. Unmounting — `componentWillUnmount`

---

## Хуки

**Что такое хуки?**

* Функции для управления состоянием и побочными эффектами в функциональных компонентах.

**useState** — для хранения состояния.

**useEffect** — для побочных эффектов (запросы, таймеры, подписки).

```jsx
useEffect(() => {
  // эффект
  return () => {
    // очистка
  };
}, [deps]);
```

**Как работает useEffect и зачем он нужен?**

* Выполняется после рендера.
* Работает как `componentDidMount`, `componentDidUpdate` и `componentWillUnmount` вместе.

**useRef** — хранение mutable объекта, который не вызывает ререндер при изменении.

**Ref и useRef — в чём разница?**

* `useRef` в функциональных компонентах, `createRef` — в классовых.
* Оба создают объект с `.current`, который ссылается на DOM или любое значение.

**useMemo / useCallback — в чём разница?**

* `useMemo` — мемоизирует результат функции (значение).
* `useCallback` — мемоизирует саму функцию.

**useContext** — работа с контекстом.

**Правила хуков:**

* Только в функциональных компонентах.
* Только на верхнем уровне вызова.

---

## Ререндеринг и оптимизация

**Когда происходит ререндер?**

* При изменении props или state.

**Как избежать лишних ререндеров?**

* `React.memo`, `useMemo`, `useCallback`, `shouldComponentUpdate`

**Ключи (key) в списках — зачем нужны?**

* Для отслеживания элементов между рендерами (помогают virtual DOM).

---

## HOC (Higher-Order Components)

**Что такое HOC и какую проблему он решает?**

* Функция, принимающая компонент и возвращающая новый компонент.
* Повторное использование логики (например, авторизация, логгинг).

```jsx
const withAuth = (Component) => (props) => isLoggedIn ? <Component {...props} /> : <Login />;
```

---

## Управление формами

**Управляемые и неуправляемые компоненты**

* Управляемые: значения хранятся в state.
* Неуправляемые: значения через `ref`.

---

## Контекст

**Что такое Context API?**

* Механизм для передачи данных без пропсов на каждом уровне.

```jsx
const MyContext = React.createContext();
<MyContext.Provider value={...}>
  <Child />
</MyContext.Provider>
```

---

## Роутинг

**Как работает маршрутизация в React?**

* С помощью `react-router-dom`:

```jsx
<BrowserRouter>
  <Routes>
    <Route path="/" element={<Home />} />
  </Routes>
</BrowserRouter>
```

**Чем отличаются Link и a?**

* `Link` не перезагружает страницу, работает через history API.

---

## Асинхронность

**Как выполнять асинхронные запросы в React?**

* Внутри `useEffect` + async/await или `fetch`, `axios` и т.д.

**Что такое Suspense и lazy?**

* Позволяют лениво загружать компоненты:

```jsx
const LazyComp = React.lazy(() => import('./Comp'));
<Suspense fallback={<div>Loading...</div>}>
  <LazyComp />
</Suspense>
```

---

## Redux

**Что такое Redux и зачем он в React-приложении?**

* Менеджер глобального состояния.
* Используется, когда много компонентов должны иметь доступ к общим данным.
* Состоит из store, actions, reducers.

---

## Стилизация

**Способы стилизации компонентов:**

* CSS / SCSS / CSS Modules
* Styled-components / Emotion (CSS-in-JS)
* Inline-стили

---

## Тестирование

**Чем тестируют React-компоненты?**

* `Jest` — тестовый раннер
* `React Testing Library` — тесты UI как пользователь

---

## Error boundaries

**Что это такое?**

* Классовые компоненты с `componentDidCatch`, ловят ошибки в потомках.

---

## Новые возможности React 19 (в разработке / alpha):

* **Async Context** — контекст, работающий с async/await.
* **Actions** — замена форм с `onSubmit`, серверные действия.
* **useTransition улучшен** — для smoother UI при async.
* **use()** — await-промисов прямо в компоненте.
* **Server Components** — лучше SSR/streaming, меньше JS на клиенте.

---

## Советы и best practices

**Коротко:**

* Разбивай на мелкие компоненты
* Используй prop-types или TypeScript
* Избегай логики в рендере
* Следи за зависимостями в useEffect
* Используй мемоизацию и lazy loading

---
